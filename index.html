<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <script type="module" src="./vendor/spline-viewer/build/spline-viewer.js"></script>
  <style>
    html, body { margin:0; height:100%; background:transparent; }
    /* Prefer svh to avoid mobile URL bar jumps */
    #outer  { position:relative; height:180svh; }
    #sticky { position:sticky; top:0; height:100svh; }
    spline-viewer { width:100%; height:100%; display:block; }

    @supports not (height: 100svh) {
      /* Fallback handled by JS (visualViewport) */
      #outer  { height:auto; }
      #sticky { height:100vh; }
    }

    /* Hide scrollbars but keep scrolling (cross-browser) */
    html, body { -ms-overflow-style: none; scrollbar-width: none; }
    html::-webkit-scrollbar, body::-webkit-scrollbar { width: 0; height: 0; display: none; }
  </style>
</head>
<body>
  <section id="outer">
    <div id="sticky">
      <spline-viewer id="viewer" url="./scene.splinecode" events-target="local"></spline-viewer>
    </div>
  </section>

  <script type="module">
    const qp    = new URLSearchParams(location.search);
    const outer = document.getElementById('outer');

    // Fallback height if parent hasn't spoken yet (rare)
    function fallbackHeight() {
      const px = parseInt(qp.get('scrollpx') || '0', 10);
      const vh = parseFloat(qp.get('scrollvh') || '170'); // only used as a fallback
      if (px) outer.style.height = px + 'px';
      else {
        const unit = (window.visualViewport?.height || window.innerHeight) / 100;
        outer.style.height = (vh * unit) + 'px';
      }
    }
    fallbackHeight();

    let rangePx = null;

    if (qp.get('external') === '1') {
      window.addEventListener('message', (e) => {
        const d = e?.data;
        if (!d) return;

        if (d.type === 'SCROLL_RANGE' && Number.isFinite(d.rangePx)) {
          rangePx = Math.max(0, d.rangePx);
          outer.style.height = (rangePx + window.innerHeight) + 'px'; // make internal range match parent
        }

        if (d.type === 'SCROLL_PROGRESS' && Number.isFinite(d.progress)) {
          const max = document.documentElement.scrollHeight - window.innerHeight;
          document.documentElement.scrollTop = d.progress * Math.max(0, max);
        }
      });

      // Keep sizes aligned if the child viewport changes (mobile URL bar, rotation)
      window.addEventListener('resize', () => {
        if (rangePx != null) outer.style.height = (rangePx + window.innerHeight) + 'px';
      });
    }
  </script>
</body>
</html>
