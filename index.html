<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- fixed zoom; consistent wheel/touch in embeds -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Mojave UFO</title>

  <!-- Self-hosted Spline viewer -->
  <script type="module" src="./vendor/spline-viewer/build/spline-viewer.js"></script>

<style>
  /* Allow the document to grow and scroll */
  html, body { margin: 0; min-height: 100%; background: transparent; overscroll-behavior: none; }

  spline-viewer { display: block; touch-action: pan-y; }

  /* Use sticky instead of absolute so the page can scroll naturally */
  #wrap { position: sticky; top: 0; height: 100vh; }

  /* Optional: if you don't need pointer interactions, uncomment to prevent wheel from being captured
  spline-viewer { pointer-events: none; }
  */
</style>
</head>
<body>
  <div id="wrap">
    <spline-viewer
      id="sv"
      url="./scene.splinecode"
      events-target="window"
      loading-anim="true"
      style="width:100%; height:100%"
    ></spline-viewer>
  </div>
<!-- Invisible scroller to provide scrollHeight for Spline Scroll Events -->
<div id="ghost-scroll" style="height:200vh; visibility:hidden; pointer-events:none;"></div>

<script>
(() => {
  const sv     = document.getElementById('sv');                 // <spline-viewer id="sv">
  const root   = document.scrollingElement || document.documentElement;
  const ghost  = document.getElementById('ghost-scroll');       // <div id="ghost-scroll">

  const q      = new URLSearchParams(location.search);
  const external = q.get('external') === '1' || q.get('external') === 'true';

  // ===== Config =====
  // How long should the scroll be? Use ?scrollvh=110 or ?scrollpx=900
  const scrollPx = (() => {
    const px = parseFloat(q.get('scrollpx') || '');
    const vh = parseFloat(q.get('scrollvh') || '');
    if (!Number.isNaN(px) && px > 0) return px;
    if (!Number.isNaN(vh) && vh > 0) return Math.round(window.innerHeight * (vh / 100));
    return Math.round(window.innerHeight * 1.2); // sensible default ~1.2 screens
  })();

  // Where does the animation visually finish on the 0..1 timeline?
  // Example: if your Spline Scroll event stops changing after ~68% => ?end=0.68
  const end = (() => {
    const e = parseFloat(q.get('end') || '');
    return Number.isFinite(e) ? Math.min(1, Math.max(0.05, e)) : 1; // default = full
  })();

  function setGhostHeight(px) {
    ghost.style.display = 'block';              // MUST be visible, not display:none
    ghost.style.height  = Math.max(1, px) + 'px';
  }

  setGhostHeight(scrollPx);
  window.addEventListener('resize', () => setGhostHeight(scrollPx));

  let internal = !external;
  let locked   = false;

  function setProgress(t) {
    try { sv.setTime?.(t); } catch {}
    if (!locked && t >= end) {
      // Trim trailing scroll so the page ends right when visuals finish
      locked = true;
      setGhostHeight(root.scrollTop + 1);
    }
  }

  function computeT() {
    const max = Math.max(1, root.scrollHeight - root.clientHeight);
    const t   = Math.min(1, Math.max(0, root.scrollTop / max));
    setProgress(t);
  }

  // Internal drive
  window.addEventListener('scroll', () => { if (internal) computeT(); }, { passive: true });
  window.addEventListener('resize', () => { if (internal) computeT(); });
  computeT();

  // External (parent-driven) still supported
  window.addEventListener('message', (e) => {
    const d = e?.data || {};
    if (!d || typeof d !== 'object') return;
    if (d.type === 'FRAMER_SCROLL_INIT') { internal = false; return; }
    if (d.type === 'FRAMER_SCROLL_PROGRESS' && typeof d.progress === 'number') {
      internal = false;
      const p = Math.min(1, Math.max(0, d.progress));
      setProgress(p);
    }
  });
})();
</script>
</body>
</html>
