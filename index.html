<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mojave UFO</title>

  <!-- Use CDN first; vendor later if desired -->
  <script type="module" src="https://unpkg.com/@splinetool/viewer@1.10.57/build/spline-viewer.js"></script>

  <style>
    /* Full-bleed viewer. By default the child won't capture scroll (parent controls it). */
    html, body { height: 100%; margin: 0; background: transparent; }
    /* Allow programmatic scroll; hide scrollbar so the child doesn't feel scrollable */
    body { overflow: auto; scrollbar-width: none; }
    body::-webkit-scrollbar { display: none; }
    #wrap { position: fixed; inset: 0; }
    spline-viewer, canvas { width: 100% !important; height: 100% !important; display: block; background: transparent !important; }

    /* Internal scroll fallback (enabled dynamically if no parent messages arrive) */
    html.internal #wrap { position: sticky; top: 0; height: 100vh; }
  </style>
</head>
<body>
  <div id="wrap">
    <spline-viewer id="sv" url="./scene.splinecode" events-target="window" loading-anim="true"></spline-viewer>
  </div>
  <!-- Invisible scroller to provide scrollHeight for Spline Scroll Events -->
  <div id="ghost-scroll" style="height:200vh; visibility:hidden; pointer-events:none; display:none;"></div>

  <script>
    (function () {
      const sv = document.getElementById('sv');
      const ghost = document.getElementById('ghost-scroll');
      const htmlEl = document.documentElement;
      const root = document.scrollingElement || document.documentElement;

      // Query param overrides
      const params = new URLSearchParams(location.search);
      const forceInternal = params.get('internal') === '1';
      const forceExternal = params.get('external') === '1';

      let internal = !!forceInternal;
      let gotParentMsg = false;
      let fallbackTimer = 0;

      // Ensure there's scrollHeight to drive Spline Scroll Events even in external mode
      if (ghost) {
        ghost.style.display = 'block';
        // Set minimal height for scroll animation - just enough to complete animation
        const scrollDistance = Math.max(window.innerHeight * 0.5, 600); // 0.5x viewport or minimum 600px
        ghost.style.height = scrollDistance + 'px';
      }

      function activateInternal() {
        if (internal) return;
        internal = true;
        htmlEl.classList.add('internal');
        if (ghost) {
          ghost.style.display = 'block';
          // Dynamically set ghost height based on viewport and desired scroll distance
          const scrollDistance = Math.max(window.innerHeight * 0.5, 600); // 0.5x viewport or minimum 600px
          ghost.style.height = scrollDistance + 'px';
        }
        // Drive timeline from this page's own scroll, so both modes behave similarly
        const computeT = () => {
          const max = Math.max(1, root.scrollHeight - root.clientHeight);
          const top = root.scrollTop || 0;
          return Math.max(0, Math.min(1, top / max));
        };
        const onScroll = () => {
          const t = computeT();
          try { const dur = Number(sv?.duration || 1); sv.setTime?.(t * dur); sv.play?.(); } catch {}
        };
        addEventListener('scroll', onScroll, { passive: true });
        onScroll();
      }

      // Play when loaded; ensure t=0 for a clean first frame
      sv?.addEventListener?.('load-complete', () => {
        try { sv.play?.(); sv.setTime?.(0); } catch {}
      });

      // If not forced external/internal, choose based on whether parent sends messages soon
      if (!forceInternal && !forceExternal) {
        fallbackTimer = window.setTimeout(() => {
          if (!gotParentMsg) activateInternal();
        }, 900);
      }
      if (forceInternal) activateInternal();

      // Receive parent scroll messages
      addEventListener('message', (e) => {
        const d = e?.data || {};
        if (d.type === 'FRAMER_SCROLL_INIT' || d.type === 'FRAMER_SCROLL') {
          gotParentMsg = true;
          if (fallbackTimer) { window.clearTimeout(fallbackTimer); fallbackTimer = 0; }
          // Ensure external mode if parent is driving
          if (!forceInternal && internal) { 
            internal = false; 
            htmlEl.classList.remove('internal'); 
            if (ghost) {
              ghost.style.display = 'block';
              // Maintain consistent ghost height in external mode
              const scrollDistance = Math.max(window.innerHeight * 0.5, 600);
              ghost.style.height = scrollDistance + 'px';
            }
          }
        }
        if (d.type === 'FRAMER_SCROLL_INIT') {
          try { sv.pause?.(); sv.setTime?.(0); } catch {}
          return;
        }
        if (d.type === 'FRAMER_SCROLL') {
          const t = Math.max(0, Math.min(1, Number(d.t) || 0));
          try { const dur = Number(sv?.duration || 1); sv.setTime?.(t * dur); sv.play?.(); } catch {}
          // Only emulate internal scroll while in external mode (so Scroll Events fire)
          if (!internal) {
            try {
              const max = Math.max(1, root.scrollHeight - root.clientHeight);
              root.scrollTo(0, t * max);
            } catch {}
          }
        }
      });

      // Safety: if viewer never registers, script didn’t load
      setTimeout(() => {
        if (!customElements.get('spline-viewer')) {
          console.warn('spline-viewer not registered — check <script src> or CSP');
        }
      }, 4000);
    })();
  </script>
</body>
</html>
