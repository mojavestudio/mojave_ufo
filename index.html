<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- fixed zoom; consistent wheel/touch in embeds -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Mojave UFO</title>

  <!-- Self-hosted Spline viewer -->
  <script type="module" src="./vendor/spline-viewer/build/spline-viewer.js"></script>

<style>
  /* Allow the document to grow and scroll */
  html, body { margin: 0; min-height: 100%; background: transparent; }

  /* Use sticky instead of absolute so the page can scroll naturally */
  #wrap { position: sticky; top: 0; height: 100vh; }

  /* Optional: if you don't need pointer interactions, uncomment to prevent wheel from being captured
  spline-viewer { pointer-events: none; }
  */
</style>
</head>
<body>
  <div id="wrap">
    <spline-viewer
      id="sv"
      url="./scene.splinecode"
      events-target="window"
      loading-anim="true"
      style="width:100%; height:100%"
    ></spline-viewer>
  </div>
<!-- Invisible scroller to provide scrollHeight for Spline Scroll Events -->
<div id="ghost-scroll" style="visibility:hidden; pointer-events:none; display:none;"></div>

<script>
(function () {
  const sv    = document.getElementById('sv');
  const html  = document.documentElement;
  const root  = document.scrollingElement || html;     // <-- cross-browser
  const ghost = document.getElementById('ghost-scroll');

  // Query flags
  const params   = new URLSearchParams(location.search);
  const external = params.get('external') === '1' || params.get('external') === 'true';

  // Mode state
  let internal       = !external;   // default to internal when no external driver
  let gotParentMsg   = false;
  let fallbackTimer  = 0;

  // Ensure spacer exists + dynamic height
  function setGhostHeight() {
    if (!ghost) return;
    ghost.style.display = 'block';
    const scrollDistance = Math.max(window.innerHeight * 1.5, 1200); // 1.5×vh or 1200px
    ghost.style.height = scrollDistance + 'px';
  }

  setGhostHeight();
  window.addEventListener('resize', setGhostHeight);

  function computeT() {
    // total scrollable distance
    const max = Math.max(1, root.scrollHeight - root.clientHeight);
    const t   = Math.min(1, Math.max(0, root.scrollTop / max));

    // Spline viewer accepts normalized timeline via setTime for scroll timelines
    try { sv.setTime?.(t); } catch {}
  }

  function activateInternal() {
    if (internal) return;
    internal = true;
    computeT(); // kick once
  }

  // If we expect a parent but never hear from it, fall back to internal after 600ms
  if (external) {
    fallbackTimer = window.setTimeout(() => {
      if (!gotParentMsg) activateInternal();
    }, 600);
  }

  // Always drive timeline from window scroll in internal mode
  window.addEventListener('scroll', () => {
    if (internal) computeT();
  }, { passive: true });
  window.addEventListener('resize', () => {
    if (internal) computeT();
  });
  computeT();

  // Parent → child messages (external mode)
  window.addEventListener('message', (e) => {
    const d = e?.data || {};
    if (!d || typeof d !== 'object') return;

    if (d.type === 'FRAMER_SCROLL_INIT') {
      gotParentMsg = true;
      if (fallbackTimer) { clearTimeout(fallbackTimer); fallbackTimer = 0; }
      // Switch to external driving
      internal = false;
      setGhostHeight();
      try { sv.pause?.(); sv.setTime?.(0); } catch {}
      return;
    }

    if (d.type === 'FRAMER_SCROLL_PROGRESS' && typeof d.progress === 'number') {
      gotParentMsg = true;
      if (fallbackTimer) { clearTimeout(fallbackTimer); fallbackTimer = 0; }
      internal = false;
      setGhostHeight();
      try { sv.setTime?.(Math.min(1, Math.max(0, d.progress))); } catch {}
      return;
    }
  });
})();
</script>
</body>
</html>
