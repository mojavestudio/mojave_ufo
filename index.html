<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1"
  />
  <title>Mojave UFO</title>

  <!-- Use your pinned viewer; do NOT load another viewer anywhere else -->
  <script type="module" src="./vendor/spline-viewer/build/spline-viewer.js"></script>
</head>
<body>
  <!-- place this <style> anywhere in the BODY (not head) -->
  <style>
    html, body { margin:0; background:transparent }
    #outer  { position:relative; width:100vw }
    #sticky { position:sticky; top:0; width:100vw; /* height set via JS lock */ }

    /* Fill the sticky box pre/post hydration */
    spline-viewer {
      display:block !important;
      width:100% !important;
      height:100% !important;
      max-width:none !important;
      min-width:0 !important;
      box-sizing:border-box !important;
    }
  </style>

  <section id="outer">
    <div id="sticky">
      <spline-viewer
        id="viewer"
        url="./scene.splinecode"
        events-target="local"
        style="display:block;width:100%;height:100%"
      ></spline-viewer>
    </div>
  </section>

  <script>
    (function () {
      console.info("[mojave_ufo] child v11 loaded", new Date().toISOString());

      const qp     = new URLSearchParams(location.search);
      const outer  = document.getElementById("outer");
      const sticky = document.getElementById("sticky");

      // --- 1) LOCK the viewport height in *pixels* to avoid post-hydration jiggle ---
      function vpH() {
        return Math.round((window.visualViewport?.height || window.innerHeight) || 0);
      }
      function lockStickyToViewport() {
        const h = vpH();
        sticky.style.height = h + "px";         // sticky box is a fixed px height
        sticky.dataset.locked = "1";
        return h;
      }
      // initial lock before anything else
      let lockedVp = lockStickyToViewport();

      // --- 2) Set OUTER scroll length (internal fallback when not embedded) ---
      function setOuterLengthFallback() {
        const px = parseInt(qp.get("scrollpx") || "0", 10);
        if (px) { outer.style.height = px + "px"; return; }
        const mult = parseFloat(qp.get("scrollvh") || "170", 10); // default 170vh
        outer.style.height = Math.round(lockedVp * (mult / 100)) + "px";
      }
      setOuterLengthFallback();

      // --- 3) Only update lock on *real* resizes to avoid tiny toolbar jitters ---
      let resizeRAF = 0, lastUpdate = Date.now();
      function maybeRelock(force = false) {
        cancelAnimationFrame(resizeRAF);
        resizeRAF = requestAnimationFrame(() => {
          const curr = vpH();
          const delta = Math.abs(curr - lockedVp);
          const enoughTime = Date.now() - lastUpdate > 300;  // debounce
          if (force || delta >= 48) {                        // ~toolbar/orientation threshold
            lockedVp = lockStickyToViewport();
            setOuterLengthFallback();
            lastUpdate = Date.now();
          }
        });
      }

      window.addEventListener("orientationchange", () => maybeRelock(true), { passive: true });
      window.visualViewport?.addEventListener("resize", () => maybeRelock(false), { passive: true });
      window.addEventListener("resize", () => maybeRelock(false), { passive: true });

      // --- 4) Parent â†” Child bridge (external=1) ---
      let haveRange = false;
      function pingParent() {
        try { window.parent?.postMessage({ type: "HELLO_FROM_CHILD", v: 11 }, "*"); } catch {}
      }
      window.addEventListener("message", (e) => {
        const d = e?.data; if (!d) return;
        if (d.type === "SCROLL_RANGE" && Number.isFinite(d.rangePx)) {
          haveRange = true;
          outer.style.height = (Math.max(0, d.rangePx) + lockedVp) + "px";
        } else if (d.type === "SCROLL_PROGRESS" && Number.isFinite(d.progress)) {
          const max = document.documentElement.scrollHeight - lockedVp;
          document.documentElement.scrollTop = d.progress * Math.max(0, max);
        }
      });

      // ask early and again after load
      if (qp.get("external") === "1") {
        pingParent();
        window.addEventListener("load", pingParent, { once: true });
        // last resort: ensure something sensible if no parent reply
        setTimeout(() => { if (!haveRange) setOuterLengthFallback(); }, 800);
      }
    })();
  </script>
</body>
</html>
