<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1"
  />
  <title>Mojave UFO</title>

  <!-- Use your pinned viewer; do NOT load another viewer anywhere else -->
  <script type="module" src="./vendor/spline-viewer/build/spline-viewer.js"></script>
</head>
<body>
  <!-- place this <style> anywhere in the BODY (not head) -->
  <style>
    html, body { margin: 0; height: 100%; background: transparent; }

    #outer  { position: relative; width: 100vw; }         /* scroll length wrapper */
    #sticky { position: sticky; top: 0; width: 100vw; height: 100svh; } /* viewport-sized */

    spline-viewer {
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
      min-width: 0 !important;
      display: block !important;
      box-sizing: border-box !important;
    }

    /* Harmless if parts don’t exist */
    spline-viewer::part(container),
    spline-viewer::part(canvas) {
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
    }
  </style>

  <section id="outer">
    <div id="sticky">
      <spline-viewer
        id="viewer"
        url="./scene.splinecode"
        events-target="local"
        style="width:100%;height:100%;display:block"
      ></spline-viewer>
    </div>
    <div id="spacer" aria-hidden="true"></div>
  </section>

  <script type="module">
    const qp    = new URLSearchParams(location.search);
    const outer = document.getElementById('outer');

    function setOuterHeight() {
      const px = parseInt(qp.get('scrollpx') || '0', 10);
      if (px) { outer.style.height = px + 'px'; return; }

      const unit = (window.visualViewport?.height || window.innerHeight) / 100;
      const vh   = parseFloat(qp.get('scrollvh') || '170', 10); // default 170vh
      outer.style.height = (vh * unit) + 'px';
    }

    setOuterHeight();
    const reapply = () => setOuterHeight();
    window.visualViewport?.addEventListener('resize', reapply);
    window.addEventListener('orientationchange', reapply);
    window.addEventListener('resize', reapply);

    // Optional: parent→child scroll sync for ?external=1
    if (qp.get('external') === '1') {
      let rangePx = null;
      window.addEventListener('message', (e) => {
        const d = e?.data;
        if (!d) return;

        if (d.type === 'SCROLL_RANGE' && Number.isFinite(d.rangePx)) {
          rangePx = Math.max(0, d.rangePx);
          outer.style.height = (rangePx + window.innerHeight) + 'px';
        } else if (d.type === 'SCROLL_PROGRESS' && Number.isFinite(d.progress)) {
          const max = document.documentElement.scrollHeight - window.innerHeight;
          requestAnimationFrame(() => {
            document.documentElement.scrollTop = d.progress * Math.max(0, max);
          });
        }
      });
    }
  </script>
</body>
</html>
