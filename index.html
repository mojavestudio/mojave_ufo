<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1"
  />
  <title>Mojave UFO</title>

  <!-- Use your pinned viewer; do NOT load another viewer anywhere else -->
  <script type="module" src="./vendor/spline-viewer/build/spline-viewer.js"></script>

  <style>
    /* --- Reset & viewport-consistent units --- */
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: transparent; }

    /* Always reference the *viewport*, not a parent’s centered layout */
    #outer  { position: relative; width: 100vw; }
    #sticky { position: sticky; top: 0; width: 100vw; height: 100svh; }

    /* Force the host element to be truly fluid (override any default max-width) */
    spline-viewer {
      width: 100vw !important;
      height: 100svh !important;
      max-width: none !important;
      min-width: 0 !important;
      display: block !important;
      margin: 0 !important;
      padding: 0 !important;
      box-sizing: border-box !important;
    }

    /* If Spline exposes parts on your build, these help; otherwise harmless no-ops */
    spline-viewer::part(container),
    spline-viewer::part(canvas) {
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
    }
  </style>
</head>
<body>
  <!-- The scrollable spacer (height set via handshake or fallback) -->
  <section id="outer">
    <div id="sticky">
      <spline-viewer
        id="viewer"
        events-target="local"
        loading="auto"
      ></spline-viewer>
    </div>
  </section>

  <script type="module">
    const qp = new URLSearchParams(location.search);
    const outer = document.getElementById('outer');
    const viewer = document.getElementById('viewer');

    // Track whether the parent provided an explicit scroll range yet
    let didReceiveRange = false;

    // Dynamic variant detection
    function getSceneUrl() {
      const isMobile = window.matchMedia('(max-width: 640px)').matches; // Adjust breakpoint as needed
      return isMobile ? './scene-mobile.splinecode' : './scene-desktop.splinecode'; // Fallback to scene.splinecode if needed
    }

    function updateScene() {
      const url = getSceneUrl();
      if (viewer.url !== url) {
        viewer.url = url; // Triggers reload in spline-viewer
      }
    }

    // Initial load
    updateScene();

    // Listen for changes (resize, orientation)
    window.addEventListener('resize', () => {
      console.log('Resize event fired. Current innerHeight:', window.innerHeight, 'visualViewport.height:', window.visualViewport?.height);
      updateScene();
    });
    window.addEventListener('orientationchange', () => {
      console.log('Orientation change event fired. Current innerHeight:', window.innerHeight, 'visualViewport.height:', window.visualViewport?.height);
      updateScene();
    });

    function applyFallbackHeight() {
      const isExternal = qp.get('external') === '1';
      if (isExternal && !didReceiveRange) {
        // In iframe mode, start at exactly 100vh until host tells us range
        const viewport = window.innerHeight;
        outer.style.height = viewport + 'px';
        console.log('External fallback height (no range yet):', viewport);
        return;
      }
      const px = parseInt(qp.get('scrollpx') || '0', 10);
      if (px) {
        console.log('Applying fallback height from scrollpx:', px);
        outer.style.height = px + 'px';
      } else {
        const vh = parseFloat(qp.get('scrollvh') || '170'); // harmless default for standalone mode
        const unit = (window.visualViewport?.height || window.innerHeight) / 100;
        console.log('Applying fallback height from scrollvh:', vh, 'unit:', unit);
        outer.style.height = (vh * unit) + 'px';
      }
    }
    applyFallbackHeight();

    let rangePx = null;

    // Parent → child sync (when embedded with ?external=1)
    if (qp.get('external') === '1') {
      window.addEventListener('message', (e) => {
        const d = e?.data;
        if (!d) return;
        if (d.type === 'SCROLL_RANGE' && Number.isFinite(d.rangePx)) {
          didReceiveRange = true;
          const raw = Number(d.rangePx);
          const viewport = window.innerHeight;
          let newHeight;
          if (raw >= viewport * 1.5) {
            // Parent likely sent TOTAL height (not range). Normalize to range.
            newHeight = Math.max(raw, viewport);
            rangePx = Math.max(0, newHeight - viewport);
          } else {
            // Parent sent RANGE (scrollable distance). Convert to total height.
            rangePx = Math.max(0, raw);
            newHeight = rangePx + viewport;
          }
          // Soft safety cap to avoid accidental runaway values
          const MAX_HEIGHT = 200000; // 200k px
          newHeight = Math.min(Math.max(newHeight, viewport), MAX_HEIGHT);
          outer.style.height = newHeight + 'px';
          console.log('Received SCROLL_RANGE message. raw:', raw, 'interpreted rangePx:', rangePx, 'applied total height:', newHeight);
        }
        if (d.type === 'SCROLL_PROGRESS' && Number.isFinite(d.progress)) {
          const max = document.documentElement.scrollHeight - window.innerHeight;
          document.documentElement.scrollTop = d.progress * Math.max(0, max);
          console.log('Received SCROLL_PROGRESS message. progress:', d.progress, 'Calculated scrollTop:', document.documentElement.scrollTop);
        }
      });

      const reapply = () => {
        const viewport = window.innerHeight;
        if (didReceiveRange && rangePx != null) {
          let newHeight = rangePx + viewport;
          const MAX_HEIGHT = 200000;
          newHeight = Math.min(Math.max(newHeight, viewport), MAX_HEIGHT);
          outer.style.height = newHeight + 'px';
          console.log('Reapplying height with range. rangePx:', rangePx, 'innerHeight:', viewport, 'New height:', newHeight);
        } else {
          // Still waiting for parent — keep it at 100vh to avoid jumps
          outer.style.height = viewport + 'px';
          console.log('Reapplying height without range — clamped to viewport:', viewport);
        }
        updateScene(); // Re-check variant on parent-triggered resizes
      };
      window.visualViewport?.addEventListener('resize', () => {
        console.log('visualViewport resize event fired. New visual height:', window.visualViewport?.height);
        reapply();
      });
      window.addEventListener('orientationchange', () => {
        console.log('Orientation change in external block. Current innerHeight:', window.innerHeight);
        reapply();
      });
      window.addEventListener('resize', () => {
        console.log('Resize event in external block. Current innerHeight:', window.innerHeight);
        reapply();
      });
    }
  </script>
</body>
</html>
