<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mojave UFO</title>
    <link rel="preload" as="image" href="./poster.png" />
    <style>
      /* Containerâ€‘driven layout: the iframe decides the size */
      html, body { margin: 0; height: 100%; background: transparent; }
      #wrap { position: absolute; inset: 0; width: 100%; height: 100%; overflow: hidden; background: transparent; }
      #poster { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; background: transparent; }
      spline-viewer { position: absolute; inset: 0; display: block; width: 100% !important; height: 100% !important; background: transparent !important; }
      .hidden { display: none !important; }
    </style>
    <!-- Load Spline viewer: try local vendor, fallback to CDN if not found -->
    <script type="module">
      const LOCAL = './vendor/spline-viewer/build/spline-viewer.js'
      const CDN = 'https://unpkg.com/@splinetool/viewer@1.10.57/build/spline-viewer.js'
      const isRegistered = () => !!customElements.get('spline-viewer')
      const tryImport = async (src) => {
        try { await import(src); return true } catch (e) {
          console.warn('[Spline] Failed to load', src, e); return false
        }
      }
      (async () => {
        let ok = await tryImport(LOCAL)
        // Give the registry a tick to settle
        if (!ok || !isRegistered()) ok = await tryImport(CDN)
        if (!isRegistered()) console.error('[Spline] viewer not registered. Check script paths.')
        else window.__SplineViewerLoaded = true
      })()
    </script>
  </head>
  <body>
    <div id="wrap">
      <img id="poster" src="./poster.png" alt="Mojave UFO" />
      <spline-viewer
        id="sv"
        background="transparent"
        loading-anim="true"
        loading="eager"
        events-target="local"
        aria-label="Spline scene"
      ></spline-viewer>
    </div>

    <script type="module">
      // Handle context loss/restoration gracefully + poster hide
      const sv = document.getElementById('sv')
      const poster = document.getElementById('poster')
      const hidePoster = () => poster && poster.classList.add('hidden')

      // Choose variant once based on container width (mobile vs desktop)
      const wrap = document.getElementById('wrap')
      const cw = Math.max(1, wrap?.clientWidth || document.documentElement.clientWidth || window.innerWidth)
      const chosen = cw <= 640 ? './scene-mobile.splinecode' : './scene-desktop.splinecode'
      try { sv.setAttribute('url', chosen) } catch { sv.setAttribute('url', './scene.splinecode') }

      // Robust first-frame sequence at t=0
      const onLoad = () => {
        try { sv.pause?.() } catch {}
        try { sv.setTime?.(0) } catch {}
        try { sv.render?.() } catch {}
        requestAnimationFrame(() => {
          try { sv.setTime?.(0) } catch {}
          hidePoster()
          // start slightly later to avoid mid-tick on slow devices
          setTimeout(() => {
            try { sv.play?.() } catch {}
            try { sv.setTime?.(0) } catch {}
          }, 120)
        })
      }
      sv?.addEventListener('load-complete', onLoad)
      // Fallback in case event name changes
      sv?.addEventListener('load', onLoad)
      // Extra safety so poster never sticks
      setTimeout(hidePoster, 6000)
      sv?.addEventListener('context-loss', () => {
        const u = sv.getAttribute('url')
        sv.setAttribute('url', '')
        requestAnimationFrame(() => sv.setAttribute('url', u))
      })

      // --- Parent scroll bridge (Framer) ---
      // Expect messages: { type: 'FRAMER_SCROLL', t: 0..1 }
      // Optional init:  { type: 'FRAMER_SCROLL_INIT' }
      let scrollMode = false
      const clamp01 = (v) => Math.max(0, Math.min(1, v))
      const scrubTo = (t) => {
        const dur = Number(sv?.duration || 1)
        try { sv.pause?.() } catch {}
        try { sv.setTime?.(clamp01(t) * dur) } catch {}
        try { sv.render?.() } catch {}
      }

      addEventListener('message', (e) => {
        if (!e?.data || typeof e.data !== 'object') return
        const { type, t } = e.data
        if (type === 'FRAMER_SCROLL_INIT') {
          scrollMode = true
          try { sv.pause?.() } catch {}
          return
        }
        if (type === 'FRAMER_SCROLL') {
          scrollMode = true
          scrubTo(Number.isFinite(t) ? t : 0)
        }
      })
    </script>
  </body>
  </html>
