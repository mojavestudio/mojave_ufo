<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1"
  />
  <title>Mojave UFO</title>

  <!-- Use your pinned viewer; do NOT load another viewer anywhere else -->
  <script type="module" src="./vendor/spline-viewer/build/spline-viewer.js"></script>
</head>
<body>
  <!-- place this <style> anywhere in the BODY (not head) -->
  <style>
    html, body { margin: 0; background: transparent; }

    /* Outer creates scroll length; sticky provides viewport box */
    #outer  { position: relative; width: 100vw; }
    #sticky { position: sticky; top: 0; width: 100vw;
              height: 100svh; height: 100dvh; height: 100lvh; }

    /* Spline fills sticky box pre/post hydration */
    spline-viewer {
      display: block !important;
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
      min-width: 0 !important;
      box-sizing: border-box !important;
    }
  </style>

  <section id="outer">
    <div id="sticky">
      <spline-viewer
        id="viewer"
        url="./scene.splinecode"
        events-target="local"
        style="display:block;width:100%;height:100%"
      ></spline-viewer>
    </div>
  </section>

  <script>
    (function () {
      const qp    = new URLSearchParams(location.search);
      const outer = document.getElementById('outer');

      // Fallback height before SCROLL_RANGE arrives (or when not embedded)
      function setFallbackHeight() {
        const px = parseInt(qp.get('scrollpx') || '0', 10);
        if (px) { outer.style.height = px + 'px'; return; }

        // Use visual viewport to avoid iOS toolbar jumps
        const vh = (window.visualViewport?.height || window.innerHeight);
        const mult = parseFloat(qp.get('scrollvh') || '170', 10); // default 170vh
        outer.style.height = (vh * (mult / 100)) + 'px';
      }

      // Recompute immediately on any viewport change (no quiet window)
      let raf = 0;
      const onVV = () => {
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(setFallbackHeight);
      };

      setFallbackHeight();
      window.visualViewport?.addEventListener('resize', onVV);
      window.addEventListener('resize', onVV);
      window.addEventListener('orientationchange', onVV);

      // --- Parent â†” Child messaging (fixes race) ---
      let haveRange = false;

      function askParentForRange() {
        try { window.parent?.postMessage({ type: 'HELLO_FROM_CHILD', v: 1 }, '*'); } catch (e) {}
      }

      window.addEventListener('message', (e) => {
        const d = e?.data;
        if (!d) return;

        if (d.type === 'SCROLL_RANGE' && Number.isFinite(d.rangePx)) {
          haveRange = true;
          const rangePx = Math.max(0, d.rangePx);
          const vp = (window.visualViewport?.height || window.innerHeight);
          outer.style.height = (rangePx + vp) + 'px';
        } else if (d.type === 'SCROLL_PROGRESS' && Number.isFinite(d.progress)) {
          const max = document.documentElement.scrollHeight - window.innerHeight;
          document.documentElement.scrollTop = d.progress * Math.max(0, max);
        }
      });

      // Ask early, on load, and on first vv-resize until we get a range
      askParentForRange();
      window.addEventListener('load', askParentForRange);
      let vvOnce = false;
      window.visualViewport?.addEventListener('resize', () => {
        if (!haveRange && !vvOnce) { vvOnce = true; askParentForRange(); }
      });

      // Last resort: reapply fallback after 1s if no range yet
      setTimeout(() => { if (!haveRange) setFallbackHeight(); }, 1000);
    })();
  </script>
</body>
</html>
