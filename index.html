<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1"
  />
  <title>Mojave UFO</title>

  <!-- put this in <head> once; keep it exactly like this -->
  <script type="module">
    if (!customElements.get('spline-viewer')) {
      import('./vendor/spline-viewer/build/spline-viewer.js');
    }
  </script>

  <style>
    html,body{margin:0;height:100%}
    #outer{position:relative;width:100vw}
    #sticky{position:sticky;top:0;width:100vw;height:100svh}
    spline-viewer{width:100vw;height:100svh;display:block}
  </style>
</head>

<body>
  <section id="outer">
    <div id="sticky">
      <spline-viewer id="viewer" events-target="global"></spline-viewer>
    </div>
  </section>

  <!-- put this just before </body> -->
  <script type="module">
    const qp = new URLSearchParams(location.search);
    const viewer = document.querySelector('spline-viewer') || (() => {
      const v = document.createElement('spline-viewer'); v.setAttribute('events-target','global'); return document.body.appendChild(v);
    })();
    // pick an existing scene; avoid tablet 404
    function pickScene(){
      const isMobile = matchMedia('(max-width: 640px)').matches;
      return isMobile ? './scene-mobile.splinecode' : './scene.splinecode';
    }
    viewer.setAttribute('events-target','global'); // scroll listens to window inside iframe
    viewer.setAttribute('url', pickScene());
    
    // Switch scenes on resize/orientation change
    addEventListener('resize', () => {
      const next = pickScene();
      if (viewer.getAttribute('url') !== next) viewer.setAttribute('url', next);
    });
    addEventListener('orientationchange', () => {
      const next = pickScene();
      if (viewer.getAttribute('url') !== next) viewer.setAttribute('url', next);
    });

    // --- scrolling logic: handshake + fallback ---
    const outer = document.getElementById('outer') || document.body.appendChild(Object.assign(document.createElement('section'),{id:'outer'}));
    const sticky = document.getElementById('sticky') || outer.appendChild(Object.assign(document.createElement('div'),{id:'sticky'}));
    if (!viewer.parentElement) sticky.appendChild(viewer);

    function setPageHeight(px){ outer.style.height = `${px}px`; }
    function defaultHeight(){
      const vh = parseFloat(qp.get('scrollvh') || '170');
      const unit = (window.visualViewport?.height || innerHeight) / 100;
      setPageHeight(vh * unit);
    }
    defaultHeight();

    let parentOk = false;
    let rangePx = 0;

    // Ask parent for control. If no reply fast, enable internal scroll so it works alone.
    function hello(){ parent.postMessage({type:'SPLINE_CHILD_HELLO'}, '*'); }
    hello();
    const helloTimer = setTimeout(() => {
      if (!parentOk) { parentOk = false; /* fallback stays active by default */ }
    }, 120);

    addEventListener('message', (e) => {
      const d = e.data || {};
      if (d.type === 'SPLINE_PARENT_ACK') {
        parentOk = true; clearTimeout(helloTimer);
      }
      if (d.type === 'SCROLL_RANGE') {
        rangePx = Math.max(0, +d.rangePx||0);
        setPageHeight(rangePx + (innerHeight||0));
      }
      if (d.type === 'SCROLL_PROGRESS') {
        const max = Math.max(0, document.documentElement.scrollHeight - (innerHeight||0));
        scrollTo(0, (Math.min(Math.max(+d.progress||0,0),1)) * max);
      }
    });

    addEventListener('orientationchange', () => rangePx && setPageHeight(rangePx + (innerHeight||0)));
    addEventListener('resize', () => rangePx && setPageHeight(rangePx + (innerHeight||0)));
  </script>
</body>
</html>