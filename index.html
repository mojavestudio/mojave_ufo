<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1"
  />
  <title>Mojave UFO</title>

  <!-- Use your pinned viewer; do NOT load another viewer anywhere else -->
  <script type="module" src="./vendor/spline-viewer/build/spline-viewer.js"></script>
</head>
<body>
  <!-- place this <style> anywhere in the BODY (not head) -->
  <style>
    html, body { margin:0; background:transparent }
    #outer  { position:relative; width:100vw }
    #sticky { position:sticky; top:0; width:100vw; /* height set via JS lock */ }

    /* Absolutely cover the sticky box so internal reflow can't move layout */
    .cover { position:absolute; inset:0; }

    /* Fill the sticky box pre/post hydration */
    spline-viewer {
      display:block !important;
      width:100% !important;
      height:100% !important;
      max-width:none !important;
      min-width:0 !important;
      box-sizing:border-box !important;
      contain: layout paint;
      opacity: 0;
      will-change: opacity;
      transition: opacity 140ms linear;
    }
  </style>

  <section id="outer">
    <div id="sticky">
      <div class="cover">
        <spline-viewer
          id="viewer"
          url="./scene.splinecode"
          events-target="local"
          loading="eager"
          style="display:block;width:100%;height:100%"
        ></spline-viewer>
      </div>
    </div>
  </section>

  <script>
    (function () {
      console.info('[mojave_ufo] child v12 loaded', new Date().toISOString());

      const qp     = new URLSearchParams(location.search);
      const outer  = document.getElementById('outer');
      const sticky = document.getElementById('sticky');

      // 1) Lock the sticky box to a concrete pixel height immediately.
      const vpH = () => Math.round((window.visualViewport?.height || window.innerHeight) || 0);
      function lockSticky(px) { sticky.style.height = px + 'px'; return px; }
      let lockedVp = lockSticky(vpH());

      // 2) Provide a sane scroll length even if no parent sync is used.
      function setOuterLengthFallback() {
        const px = parseInt(qp.get('scrollpx') || '0', 10);
        if (px) { outer.style.height = px + 'px'; return; }
        const mult = parseFloat(qp.get('scrollvh') || '170', 10); // default 170vh
        outer.style.height = Math.round(lockedVp * (mult / 100)) + 'px';
      }
      setOuterLengthFallback();

      // 3) Only re-lock when the viewport really changes (avoid iOS toolbar jitter).
      let raf = 0, lastUpdate = Date.now();
      function maybeRelock(force=false) {
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          const curr = vpH();
          const delta = Math.abs(curr - lockedVp);
          const enoughTime = Date.now() - lastUpdate > 300;
          if (force || (delta >= 48 && enoughTime)) {
            lockedVp = lockSticky(curr);
            setOuterLengthFallback();
            lastUpdate = Date.now();
          }
        });
      }
      window.addEventListener('orientationchange', () => maybeRelock(true), { passive:true });
      window.visualViewport?.addEventListener('resize', () => maybeRelock(false), { passive:true });
      window.addEventListener('resize', () => maybeRelock(false), { passive:true });

      // 4) Optional: parent<->child range/progress sync when you use ?external=1
      let haveRange = false;
      function askParent() { try { parent?.postMessage({ type:'HELLO_FROM_CHILD', v:12 }, '*'); } catch {} }

      window.addEventListener('message', (e) => {
        const d = e?.data; if (!d) return;
        if (d.type === 'SCROLL_RANGE' && Number.isFinite(d.rangePx)) {
          haveRange = true;
          outer.style.height = (Math.max(0, d.rangePx) + lockedVp) + 'px';
        } else if (d.type === 'SCROLL_PROGRESS' && Number.isFinite(d.progress)) {
          const max = document.documentElement.scrollHeight - lockedVp;
          document.documentElement.scrollTop = d.progress * Math.max(0, max);
        }
      });

      if (qp.get('external') === '1') {
        askParent();
        window.addEventListener('load', askParent, { once:true });
        setTimeout(() => { if (!haveRange) setOuterLengthFallback(); }, 800);
      }
    })();
  </script>

  <script>
    // Reveal the viewer only when Spline reports the scene is fully loaded
    customElements.whenDefined('spline-viewer').then(() => {
      const viewer = document.getElementById('viewer');
      if (!viewer) return;

      // Ensure hidden on init or reload
      viewer.style.opacity = '0';

      // Spline-documented lifecycle events
      viewer.addEventListener('load-start', () => {
        viewer.style.opacity = '0';
      });

      viewer.addEventListener('load-complete', () => {
        // Two RAFs to ensure a stable paint before revealing
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            viewer.style.opacity = '1';
          });
        });
      });
    });
  </script>
</body>
</html>
