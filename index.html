<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1"
  />
  <title>Mojave UFO</title>
  <!-- CSS units fixed: 100vw/100svh (no spaces) -->

  <!-- Use your pinned viewer; do NOT load another viewer anywhere else -->
  <script>if (!window.THREE) window.THREE = {};</script>  <!-- Guard against multiple Three.js -->
  <script type="module" src="./vendor/spline-viewer/build/spline-viewer.js"></script>

</head>
<body>
  <!-- place this <style> anywhere in the BODY (not head) -->
  <style>
    html, body { margin:0; height:100%; background:transparent; overflow:hidden; }
    #outer  { position:relative; width:100vw; overflow:hidden; }
    #sticky { position:sticky; top:0; width:100vw; height:100vh; height:100svh; overflow:hidden; }

    /* Absolutely cover the sticky box so internal reflow can't move layout */
    .cover { position:absolute; inset:0; visibility:hidden; }
    .cover.ready { visibility:visible; }

    /* Fill the sticky box pre/post hydration */
    spline-viewer {
      display:block !important;
      width:100vw !important;
      height:100svh !important;
      max-width:none !important;
      min-width:0 !important;
      box-sizing:border-box !important;
      contain: layout paint;
      opacity:1 !important;
      visibility:visible !important;
    }
    /* Hide scrollbar UI without disabling scrolling logic */
    html { scrollbar-width: none; }                 /* Firefox */
    ::-webkit-scrollbar { width: 0; height: 0; }    /* WebKit */
    spline-viewer::part(container),
    spline-viewer::part(canvas){
      width:100% !important;
      height:100% !important;
      max-width:none !important;
    }
  </style>

  <section id="outer">
    <div id="sticky">
      <div class="cover" id="cover">
        <spline-viewer
          id="viewer"
          events-target="local"
          loading="eager"
          style="display:block;width:100%;height:100%"
        ></spline-viewer>
        <script type="module">
          const viewer = document.getElementById('viewer');
          async function pickScene() {
            for (const p of ["scene.splinecode", "scene-mobile.splinecode", "scene-desktop.splinecode"]) {  // Reordered to prefer existing
              try { 
                const r = await fetch(p, { method:"HEAD", cache:"no-store" }); 
                if (r.ok) return p; 
              } catch {}  // Silent on failure
            }
            return null;
          }
          (async () => {
            const chosen = await pickScene();
            if (chosen) viewer.setAttribute("url", chosen);
          })();
        </script>
      </div>
    </div>
  </section>

  <script>
    (function () {
      const t0 = performance.now();
      const log = (...a) => console.log('[mojave_ufo]', ...a);

      const qp     = new URLSearchParams(location.search);
      const outer  = document.getElementById('outer');
      const sticky = document.getElementById('sticky');
      const cover  = document.getElementById('cover');
      const viewer = document.getElementById('viewer');
      // Build absolute URLs so the viewer (which uses an internal iframe) can fetch correctly
      const SITE_BASE = new URL('./', location.href).href; // e.g. https://.../mojave_ufo/
      // Default scene (used only when no explicit params are provided)
      const SCENE_URL = SITE_BASE + 'scene.splinecode';
      // Optional: pass both to let the page auto-pick by width
      const URL_MOBILE  = qp.get('urlMobile') || '';
      const URL_DESKTOP = qp.get('urlDesktop') || '';
      // Force a breakpoint via link: ?bp=mobile or ?bp=desktop
      const BP = (qp.get('bp') || '').toLowerCase();
      const MOBILE_SCENE  = SCENE_URL;
      const DESKTOP_SCENE = SCENE_URL;
      const BP_WIDTH = parseFloat(qp.get('bpWidth') || '768');

      // --- 1) PIXEL-LOCK the sticky container (no vh/svh volatility) ---
      const vpH = () => Math.round((visualViewport?.height || innerHeight) || 0);
      function lockSticky(px){ sticky.style.height = px + 'px'; return px; }
      let lockedVp = lockSticky(vpH());
      log('lockSticky', { lockedVp, t: (performance.now()-t0).toFixed(1)+'ms' });

      // --- 2) Provide internal scroll length BEFORE any paint (standalone fallback) ---
      function setOuterFallback(){
        const px = parseInt(qp.get('scrollpx') || '0', 10);
        if (px) { outer.style.height = px + 'px'; return; }
        const mult = parseFloat(qp.get('scrollvh') || '170', 10);
        outer.style.height = Math.round(lockedVp * (mult / 100)) + 'px';
      }
      // Only apply fallback height when NOT embedded (prevents iframe scrollbar)
      const isExternal = qp.get('external') === '1';
      if (!isExternal) {
        setOuterFallback();
      }

      // Only re-lock on REAL resizes (orientation / big delta)
      let raf = 0, last = Date.now();
      function maybeRelock(force=false){
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          const curr = vpH(), delta = Math.abs(curr - lockedVp);
          const enough = Date.now() - last > 300;
          if (force || (delta >= 48 && enough)) {
            lockedVp = lockSticky(curr);
            // Recompute fallback only if we're not in external mode or never got a range
            if (!isExternal || !gotRange) {
              if (!isExternal) {
                setOuterFallback();
              }
            }
            last = Date.now();
            log('relock', { lockedVp, delta, t: (performance.now()-t0).toFixed(1)+'ms' });
          }
        });
      }
      addEventListener('orientationchange', () => maybeRelock(true), { passive:true });
      visualViewport?.addEventListener('resize', () => maybeRelock(false), { passive:true });
      addEventListener('resize', () => maybeRelock(false), { passive:true });

      // --- 3) Gate loading: wait for stable non-zero size, then set URL ---
      let urlSet = false;
      let stableFrames = 0;
      let prevW = 0, prevH = 0;
      const tolerance = 0.5; // px
      const ro = new ResizeObserver((entries) => {
        const rect = entries[0]?.contentRect;
        if (!rect) return;
        const { width, height } = rect;
        const wStable = Math.abs(width - prevW) <= tolerance;
        const hStable = Math.abs(height - prevH) <= tolerance;
        if (width > 0 && height > 0 && wStable && hStable) {
          stableFrames++;
        } else {
          stableFrames = 0;
        }
        prevW = width; prevH = height;
        if (!urlSet && stableFrames >= 2) {
          urlSet = true;
          // Allow quick override via ?url= for testing
          const overrideUrl = qp.get('url');
          let finalUrl = SCENE_URL;
          let mode = 'default';

          if (overrideUrl) {
            finalUrl = overrideUrl;
            mode = 'override';
          } else if (BP === 'mobile') {
            finalUrl = MOBILE_SCENE;
            mode = 'mobile:forced';
          } else if (BP === 'desktop') {
            finalUrl = DESKTOP_SCENE;
            mode = 'desktop:forced';
          } else if (URL_MOBILE || URL_DESKTOP) {
            const isMobile = width <= BP_WIDTH;
            finalUrl = isMobile
              ? (URL_MOBILE || URL_DESKTOP || SCENE_URL)
              : (URL_DESKTOP || URL_MOBILE || SCENE_URL);
            mode = isMobile ? 'mobile:auto' : 'desktop:auto';
          }
          try { viewer.setAttribute('url', finalUrl); } catch {}
          ro.disconnect();
          log('set url', { finalUrl, mode, bp: BP_WIDTH, width, height, t: (performance.now()-t0).toFixed(1)+'ms' });
        }
      });
      ro.observe(sticky);

      // --- 4) Gate visibility: reveal only when everything is ready ---
      let gotLoad = false, gotRange = false, gotProgress = false;
      let rangePx = 0;

      function tryReveal() {
        if (!gotLoad) return;
        if (isExternal && !(gotRange && gotProgress)) return;

        if (gotRange) {
          outer.style.height = (rangePx + lockedVp) + 'px';
        }

        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            cover.classList.add('ready');
            log('REVEAL', { t: (performance.now()-t0).toFixed(1)+'ms' });
          });
        });
      }

      // Spline lifecycle events
      customElements.whenDefined('spline-viewer').then(() => {
        viewer.addEventListener('load-start', () => log('load-start', (performance.now()-t0).toFixed(1)+'ms'));
        viewer.addEventListener('load-complete', () => {
          gotLoad = true;
          log('load-complete', (performance.now()-t0).toFixed(1)+'ms');
          tryReveal();
        });
      });

      // --- 5) Parent ↔ child bridge for ?external=1 (wait for BOTH signals) ---
      if (isExternal) {
        function pingParent(){ try { parent?.postMessage({ type:'HELLO_FROM_CHILD', v:13 }, '*'); } catch {} }
        addEventListener('message', (e) => {
          const d = e?.data; if (!d) return;
          if (d.type === 'SCROLL_RANGE' && Number.isFinite(d.rangePx)) {
            rangePx = Math.max(0, d.rangePx);
            gotRange = true;
            log('SCROLL_RANGE', { rangePx, t: (performance.now()-t0).toFixed(1)+'ms' });
            tryReveal();
          } else if (d.type === 'SCROLL_PROGRESS' && Number.isFinite(d.progress)) {
            gotProgress = true;
            if (cover.classList.contains('ready')) {
              const max = document.documentElement.scrollHeight - lockedVp;
              document.documentElement.scrollTop = d.progress * Math.max(0, max);
            }
            log('SCROLL_PROGRESS', { progress: d.progress.toFixed(3), t: (performance.now()-t0).toFixed(1)+'ms' });
            tryReveal();
          }
        });
        pingParent();
        addEventListener('load', pingParent, { once:true });
        setTimeout(() => {
          if (!(gotRange && gotProgress)) {
            log('no parent reply → fallback', (performance.now()-t0).toFixed(1)+'ms');
            tryReveal();
          }
        }, 1000);
      }
    })();
  </script>
  <script type="module">
    // Bullet-proof fallback: ensure the viewer always receives a valid URL
    async function pickUrl() {
      const preferred = (innerWidth < 600)
        ? "scene-mobile.splinecode"
        : (innerWidth < 1024)
          ? "scene-tablet.splinecode"
          : "scene-desktop.splinecode";
      const candidates = [
        preferred,
        "scene.splinecode",
        "scene-desktop.splinecode",
        "scene-tablet.splinecode",
        "scene-mobile.splinecode",
      ];
      for (const p of candidates) {
        try {
          const r = await fetch(p, { method: 'HEAD', cache: 'no-store' });
          if (r.ok) return p;
        } catch {}
      }
      throw new Error('No scene*.splinecode found at repo root');
    }

    (async () => {
      const v = document.querySelector('spline-viewer');
      if (!v) return;
      // If main script already set a URL, do nothing
      if (v.getAttribute('url')) return;
      try {
        const url = await pickUrl();
        v.setAttribute('url', url);
      } catch (err) {
        console.error('[mojave_ufo] failed to pick scene url', err);
      } finally {
        // Make sure it is visible even if other CSS hid it
        v.style.opacity = '1';
        v.style.visibility = 'visible';
      }
    })();
  </script>
</body>
</html>
