<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- fixed zoom; consistent wheel/touch in embeds -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Mojave UFO</title>

  <!-- Self-hosted Spline viewer -->
  <script type="module" src="./vendor/spline-viewer/build/spline-viewer.js"></script>

<style>
  /* Allow the document to grow and scroll */
  html, body { margin: 0; min-height: 100%; background: transparent; }

  spline-viewer { display: block; touch-action: pan-y; }

  /* Use sticky instead of absolute so the page can scroll naturally */
  #wrap { position: sticky; top: 0; height: 100vh; }

  /* Optional: if you don't need pointer interactions, uncomment to prevent wheel from being captured
  spline-viewer { pointer-events: none; }
  */
</style>
</head>
<body>
  <div id="wrap">
    <spline-viewer
      id="sv"
      url="./scene.splinecode"
      events-target="window"
      loading-anim="true"
      style="width:100%; height:100%"
    ></spline-viewer>
  </div>
<!-- Invisible scroller to provide scrollHeight for Spline Scroll Events -->
<div id="ghost-scroll" style="height:200vh; visibility:hidden; pointer-events:none;"></div>

<script>
(function () {
  const sv     = document.getElementById('sv');
  const html   = document.documentElement;
  const root   = document.scrollingElement || html;
  const ghost  = document.getElementById('ghost-scroll');

  const params   = new URLSearchParams(location.search);
  const external = params.get('external') === '1' || params.get('external') === 'true';

  // --- 1) Configurable scroll distance ---
  // Use ?scrollvh=120 (vh units) or ?scrollpx=900 (px). Defaults to 120vh if nothing is given.
  function targetScrollPx() {
    const px  = parseFloat(params.get('scrollpx') || '');
    const vh  = parseFloat(params.get('scrollvh') || '');
    if (!Number.isNaN(px) && px > 0) return px;
    if (!Number.isNaN(vh) && vh > 0) return Math.round(window.innerHeight * (vh / 100));
    return Math.round(window.innerHeight * 1.2); // default: ~1.2 screens
  }

  function setGhostHeight(px) {
    ghost.style.height = Math.max(1, px) + 'px';
    ghost.style.display = 'block';
  }

  // Initial spacer (you can tweak with ?scrollvh / ?scrollpx)
  setGhostHeight(targetScrollPx());
  window.addEventListener('resize', () => setGhostHeight(targetScrollPx()));

  // --- 2) Drive Spline from scroll + auto-lock at the end ---
  let internal = !external;    // default to internal if no parent driver
  let locked   = false;        // becomes true once we reach t == 1

  function computeT() {
    const max = Math.max(1, root.scrollHeight - root.clientHeight);
    const t   = Math.min(1, Math.max(0, root.scrollTop / max));
    try { sv.setTime?.(t); } catch {}
    if (!locked && t >= 1) {
      locked = true;
      setGhostHeight(root.scrollTop + 1);
    }
  }

  window.addEventListener('scroll', () => { if (internal) computeT(); }, { passive: true });
  window.addEventListener('resize', () => { if (internal) computeT(); });
  computeT();

  // External (parent-driven) support stays intact
  window.addEventListener('message', (e) => {
    const d = e?.data || {};
    if (!d || typeof d !== 'object') return;
    if (d.type === 'FRAMER_SCROLL_INIT') { internal = false; return; }
    if (d.type === 'FRAMER_SCROLL_PROGRESS' && typeof d.progress === 'number') {
      internal = false;
      const p = Math.min(1, Math.max(0, d.progress));
      try { sv.setTime?.(p); } catch {}
      if (!locked && p >= 1) { locked = true; setGhostHeight(root.scrollTop + 1); }
    }
  });
})();
</script>
</body>
</html>
